(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{180:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return p}));var a=n(3),r=n(7),o=(n(0),n(549)),i={title:"The PathQuery API"},s={unversionedId:"api/pathquery",id:"api/pathquery",isDocsHomePage:!1,title:"The PathQuery API",description:"InterMine installations accept queries over their data in a custom format known as Path-Queries. This is a graph-based query format which inherits some of its semantics and terminology from SQL.",source:"@site/docs/api/pathquery.md",slug:"/api/pathquery",permalink:"/im-docs/docs/next/api/pathquery",editUrl:"https://github.com/intermine/im-docs/edit/master/docs/api/pathquery.md",version:"current",sidebar:"someSidebar",previous:{title:"Using Class and Field Labels",permalink:"/im-docs/docs/next/data-model/data-labels"},next:{title:"Querying over genomic ranges",permalink:"/im-docs/docs/next/data-model/overlaps"}},l=[{value:"Paths",id:"paths",children:[]},{value:"Queries",id:"queries",children:[{value:"The View: Defining Output Columns",id:"the-view-defining-output-columns",children:[]},{value:"Joins: Handling null values",id:"joins-handling-null-values",children:[]},{value:"Constraints: Restricting matching values",id:"constraints-restricting-matching-values",children:[]}]},{value:"Sort Order",id:"sort-order",children:[]}],c={toc:l};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"InterMine installations accept queries over their data in a custom format known as ",Object(o.b)("em",{parentName:"p"},"Path-Queries"),". This is a graph-based query format which inherits some of its semantics and terminology from SQL."),Object(o.b)("h2",{id:"paths"},"Paths"),Object(o.b)("p",null,"The core concept of ",Object(o.b)("em",{parentName:"p"},"Path-Queries")," is naturally enough the ",Object(o.b)("em",{parentName:"p"},"Path"),", examples of which are:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Gene"),": A plain root."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Gene.symbol"),": A root and an attribute."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Gene.chromosomeLocation"),": A reference to a complex attribute ","(","a reference",")","."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Gene.organism.name"),": A chain from a root to an attribute through one or more references."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Gene.pathways.identifier"),": A path may potentially match multiple values i.e. there may be several pathway identifiers that match this path for any given gene."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Protein.gene.homologues.homologue.alleles.alleleClass"),": Paths may be of arbitrary length.")),Object(o.b)("p",null,"In the XML serialization of path-queries, all paths must be completely qualified. In the JSON format, a prefix can be specified with the ",Object(o.b)("inlineCode",{parentName:"p"},"from")," or ",Object(o.b)("inlineCode",{parentName:"p"},"root")," property."),Object(o.b)("h2",{id:"queries"},"Queries"),Object(o.b)("p",null,"Queries associate paths with various parts of the query:"),Object(o.b)("h3",{id:"the-view-defining-output-columns"},"The View: Defining Output Columns"),Object(o.b)("p",null,"To define what is retrieved from the data-store, a view is defined. This is simply a list of paths; any information in the data-store graph that matches these paths and satisfies the constraints ","(","see below",")"," will be included in the results."),Object(o.b)("p",null,"eg:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-markup"}),'<query model="genomic" view="Organism.name Organism.taxonId"/>\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'{from: "Organism", select: ["name", "taxonId"]}\n')),Object(o.b)("h3",{id:"joins-handling-null-values"},"Joins: Handling null values"),Object(o.b)("p",null,"In any chain of references in a long path such as ",Object(o.b)("inlineCode",{parentName:"p"},"Gene.sequence.residues")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Gene.proteins.proteinDomains.name"),", there may be null values. There are two behaviours supported for dealing with null references ","(","i.e. where a gene does not have any sequence attached, or it has no proteins, or those proteins have no protein domains",")"," and they are:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"INNER JOIN"),": This is the default behaviour. It prevents the entire path from matching, so that if the query contains ",Object(o.b)("inlineCode",{parentName:"li"},"Gene.symbol")," and ",Object(o.b)("inlineCode",{parentName:"li"},"Gene.proteins.name")," and a gene in the data store has no proteins, then that gene will not match at all, and no data will be returned for the symbol of that gene i.e. it is a required feature of this query that all genes in the result set have at least one protein ","(","this is a kind of implicit existential constraint",")","."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"OUTER JOIN"),": This is an optional behaviour. It allows references in paths to be empty while permitting higher parts of the path to continue to match. So for example, if the query contains ",Object(o.b)("inlineCode",{parentName:"li"},"Gene.symbol")," and ",Object(o.b)("inlineCode",{parentName:"li"},"Gene.proteins.name")," and a gene in the data store has no proteins, then no protein data for that gene will be returned, but the gene will still match the query, and the symbol for that gene will be included in the retrieved results ","(","this makes the proteins optional",")",".")),Object(o.b)("p",null,"Some of the consequences of using outer joins are as follows:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Due to the optional nature of the outer joined data, it is not permitted to sort on attributes in an outer joined section."),Object(o.b)("li",{parentName:"ul"},"Constraints ","(","see below",")"," cannot be combined in an ",Object(o.b)("inlineCode",{parentName:"li"},"or")," relationship across join boundaries. So one cannot ask for all genes which are either of a certain length or which have a certain pathway if there is an outer join on pathways.")),Object(o.b)("p",null,"eg:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-markup"}),'<query model="genomic" view="Gene.symbol Gene.pathways.identifier">\n  <join path="Gene.pathways" style="OUTER"/>\n</query>\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'{from: "Gene", select: ["symbol", "pathways.identifier"], joins: ["pathways"]}\n')),Object(o.b)("h3",{id:"constraints-restricting-matching-values"},"Constraints: Restricting matching values"),Object(o.b)("p",null,"By default, all values of a given type match a query unless they are excluded by empty references on an inner joined path. To restrict the result set, constraints can be used."),Object(o.b)("h4",{id:"constraints-on-attributes"},"Constraints on attributes:"),Object(o.b)("p",null,"The following are examples of constraints on attributes in the data store:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-markup"}),'<constraint path="Gene.symbol" op="=" value="eve"/>\n<constraint path="Gene.length" op="&gt;" value="12345"/>\n<constraint path="Gene.homologues.homologue.organism.taxonId" op="!=" value="7227"/>\n<constraint path="Gene.description" op="CONTAINS" value="some term"/>\n')),Object(o.b)("p",null,"The JSON format allows a couple of different mechanisms for describing constraints such as:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'{\n  select: ["Gene.symbol"],\n  where: {\n    "symbol": "eve",\n    "length": {gt: 12345},\n    "homologues.homologue.organism.taxonId": {"!=": 7227},\n    "description": {contains: "some term"}\n  }\n}\n')),Object(o.b)("p",null,"or:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'{\n  select: ["Gene.symbol"],\n  where: [\n    {path: "symbol", op: "=", value: "eve"},\n    {path: "length", op: ">", value: 12345},\n    {path: "homologues.homologue.organism.taxonId", op: "!=", value: 7227},\n    {path: "description", op: "CONTAINS", value: "some term"}\n  ]\n}\n')),Object(o.b)("p",null,"or"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'{\n  select: ["Gene.symbol"],\n  where: [\n    [ "symbol", "=", "eve" ],\n    [ "length", ">", 12345 ],\n    [ "homologues.homologue.organism.taxonId", "!=", 7227 ],\n    [ "description", "CONTAINS", "some term" ]\n  ]\n}\n')),Object(o.b)("h4",{id:"multi-value-constraints"},"Multi-Value Constraints"),Object(o.b)("p",null,"One can specify that a path resolves to a value matching one ","(","or none",")"," of a set of values. This can be done like so:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-markup"}),'<constraint path="Gene.symbol" op="ONE OF">\n  <value>eve</value>\n  <value>bib</value>\n  <value>zen</value>\n</constraint>\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'{\n  select: ["Gene.proteins.name"],\n  where: {\n    symbol: ["eve", "bib", "zen"]\n  }\n}\n')),Object(o.b)("p",null,"A special sub-type of this kind of constraint is the range constraint shown below:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-markup"}),'<constraint path="Gene.chromosomeLocation" op="OVERLAPS">\n  <value>X:12345..45678</value>\n  <value>2L:12345..45678</value>\n  <value>3R:12345</value>\n</constraint>\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'{\n  select: ["Gene.symbol"],\n  where: {\n    chromosomeLocation: {OVERLAPS: ["X:12345..45678", "2L:34567..78654", "3R:12345"]}\n  }\n}\n')),Object(o.b)("h4",{id:"lookup-constraints"},"Lookup Constraints"),Object(o.b)("p",null,"Lookup constraints allow convenient constraints over multiple attributes of a value, or querying when you don't know the particular attribute you wish to constrain. For example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-markup"}),'<constaint path="Gene" op="LOOKUP" value="eve"/>\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'{\n  select: ["Gene.symbol"],\n  where: [[ "Gene", "LOOKUP", "eve"]]\n}\n')),Object(o.b)("p",null,"An extra disambiguating value can be supplied. Its meaning depends on context, so for example, this would limit genes to a particular organism:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-markup"}),'<constaint path="Gene" op="LOOKUP" value="eve" extraValue="D. melanogaster"/>\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'{\n  select: ["Gene.symbol"],\n  where: [[ "Gene", "LOOKUP", "eve", "D. melanogaster"]]\n}\n')),Object(o.b)("h4",{id:"list-constraints"},"List Constraints"),Object(o.b)("p",null,"Nodes in the query graph can be constrained by membership in a stored list. This type of constraint is similar to multi-value constraints, in that we are looking at membership in a set, and also similar to lookup constraints in that we treat entities as subjects of the constraints, rather than values of any of the attributes of the entities. A simple example is selecting all the proteins for genes in a given list as shown below:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-markup"}),'<constraint path="Protein.genes" op="IN" value="a given list"/>\n\x3c!-- Or to exclude those records --\x3e\n<constraint path="Protein.genes" op="NOT IN" value="a given list"/>\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'{\n  select: ["Protein.*"],\n  where: [["genes", "IN", "a given list"]]\n}\n')),Object(o.b)("p",null,'The only relationships that may be asserted are "IN" and "NOT IN".'),Object(o.b)("h4",{id:"loop-constraints"},"Loop Constraints"),Object(o.b)("p",null,"Queries can require that two nodes in the query graph refer ","(","or do not refer",")",' to the same entity. This kind of constraint is termed a "Loop" constraint. An example of this would be to request all the genes in the pathways a given gene is in, so long as they are ',"(","or are not",")"," one of the orthologues of the gene in question."),Object(o.b)("p",null,"A loop constraint is composed of two paths, and either ",Object(o.b)("inlineCode",{parentName:"p"},"=")," or ",Object(o.b)("inlineCode",{parentName:"p"},"!="),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-markup"}),'<constraint path="Gene.homologues.homologue" op="=" value="Gene.pathways.genes"/>\n\x3c!-- or --\x3e\n<constraint path="Gene.homologues.homologue" op="!=" value="Gene.pathways.genes"/>\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'{\n  select: ["Gene.homologues.homologue.*", "Gene.pathways.genes.*"],\n  where: [\n    ["Gene.symbol", "=", "x"],\n    ["Gene.homologues.homologue", "=", "Gene.pathways.genes"]\n  ]\n}\n')),Object(o.b)("p",null,"Loop constraints must link paths that are not separated by ",Object(o.b)("inlineCode",{parentName:"p"},"outer joins"),"."),Object(o.b)("h4",{id:"type-constraints"},"Type Constraints"),Object(o.b)("p",null,"Type constraints, in addition to limiting the returned results, have the side-effect of type-casting the references in their paths to the given type, enabling other paths to reference otherwise unreferenceable fields."),Object(o.b)("p",null,"eg."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-markup"}),'<constraint path="Gene.overlappingFeatures" type="ChromosomeStructureVariation"/>\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'{\n  from: "Gene",\n  select: ["symbol", "overlappingFeatures.element1.primaryIdentifier"],\n  where: {\n    overlappingFeatures: "ChromosomeStructureVariation"\n  }\n}\n')),Object(o.b)("p",null,"Type constraints may not participate in the constraint logic, and as such, never have a ",Object(o.b)("inlineCode",{parentName:"p"},"code")," associated with them."),Object(o.b)("h2",{id:"sort-order"},"Sort Order"),Object(o.b)("p",null,"The order of the results can be determined through the sort order like so:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-markup"}),'<query model="genomic" view="Gene.symbol" sortOrder="Gene.length DESC Gene.name ASC"/>\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'{select: ["Gene.symbol"], sortOrder: [["length", "DESC"], ["name", "ASC"]]}\n')))}p.isMDXComponent=!0},549:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return h}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),p=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},b=function(e){var t=p(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),b=p(n),m=a,h=b["".concat(i,".").concat(m)]||b[m]||u[m]||o;return n?r.a.createElement(h,s(s({ref:t},c),{},{components:n})):r.a.createElement(h,s({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);